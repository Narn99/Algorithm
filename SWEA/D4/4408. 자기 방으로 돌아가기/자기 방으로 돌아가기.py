# 자기 방으로 돌아가기
# 앞 방 -> 뒷 방으로 이동하는데, 복도 중간에서 이동 경로가 겹치면 한 차례 기다렸다가 이동해야됨.
# 방 번호에 -1하고 //2해서 나오는게 열 인덱스
# 1 -> 4와 3 ->6은 1열 -> 2열 , 2열 -> 3열로 이동하면서 2열에서 겹치는 사람이 생기므로 2타임
# 1 -> 3과 2 -> 200은 1열->2열, 1열 -> 100열로 이동하면서 1열~ 2열에서 2명이 겹치므로 2타임
# 그냥 사람들이 지나가는 경로에 +1을 해주고, 그 최댓값이 답일 듯. 카운팅하기.


T = int(input())

for case in range(1, T+1) :

    N = int(input())
    cnt = [0] * 200         # 이동경로상 몇 명이 겹치는지 확인용

    for _ in range(N) :
        a, b = map(int,input().split())     # 그림에 따르면, 방번호에 -1해서 2로 나눈 몫이 같은 방은 마주보는 위치
        if a != b :             # 만약 같은 방에 있으면, 이동할 일도 없다.
            if b >= a :         # b가 a보다 크거나 같다면,
                aindex = (a-1)//2
                bindex = (b-1)//2
                for i in range(aindex, bindex+1) :  # 지나가는 복도 경로에 1을 더해줌
                    cnt[i] += 1
            else :              # a가 b보다 크다면,
                aindex = (a-1)//2
                bindex = (b-1)//2
                for i in range(bindex, aindex+1) :
                    cnt[i] += 1
    else :
        print(f'#{case} {max(cnt)}')        # 경로의 최댓값이 겹치는 인원 = 걸리는 시간